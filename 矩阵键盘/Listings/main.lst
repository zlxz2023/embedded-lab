C51 COMPILER V9.60.7.0   MAIN                                                              09/18/2024 17:15:41 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\Keil\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main.ls
                    -t) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg52.h>
   2          #include <intrins.h>
   3          #define uint unsigned int
   4          #define uchar unsigned char
   5          
   6          // 共阴极0-F
   7          uchar table[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07,
   8                              0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71};
   9          
  10          void delay_10us(uint z){
  11   1          while(z--);
  12   1      }
  13          
  14          // 行列扫描
  15          uint key_scan(){
  16   1          uint key_value = 0;
  17   1          
  18   1          P1=0xf7; //给第一列赋值0，其余全为1
  19   1              if(P1!=0xf7)//判断第一列按键是否按下
  20   1              {
  21   2                      delay_10us(1000);//消抖
  22   2                      switch(P1)//保存第一列按键按下后的键值  
  23   2                      {
  24   3                              case 0x77: key_value=1;break;
  25   3                              case 0xb7: key_value=5;break;
  26   3                              case 0xd7: key_value=9;break;
  27   3                              case 0xe7: key_value=13;break;
  28   3                      }
  29   2              }
  30   1              while(P1!=0xf7);//等待按键松开  
  31   1          
  32   1          P1=0xfb;//给第二列赋值0，其余全为1
  33   1              if(P1!=0xfb)//判断第二列按键是否按下
  34   1              {
  35   2                      delay_10us(1000);//消抖
  36   2                      switch(P1)//保存第二列按键按下后的键值  
  37   2                      {
  38   3                              case 0x7b: key_value=2;break;
  39   3                              case 0xbb: key_value=6;break;
  40   3                              case 0xdb: key_value=10;break;
  41   3                              case 0xeb: key_value=14;break;
  42   3                      }
  43   2              }
  44   1              while(P1!=0xfb);//等待按键松开  
  45   1              
  46   1              P1=0xfd;//给第三列赋值0，其余全为1
  47   1              if(P1!=0xfd)//判断第三列按键是否按下
  48   1              {
  49   2                      delay_10us(1000);//消抖
  50   2                      switch(P1)//保存第三列按键按下后的键值  
  51   2                      {
  52   3                              case 0x7d: key_value=3;break;
  53   3                              case 0xbd: key_value=7;break;
  54   3                              case 0xdd: key_value=11;break;
C51 COMPILER V9.60.7.0   MAIN                                                              09/18/2024 17:15:41 PAGE 2   

  55   3                              case 0xed: key_value=15;break;
  56   3                      }
  57   2              }
  58   1              while(P1!=0xfd);//等待按键松开  
  59   1              
  60   1              P1=0xfe;//给第四列赋值0，其余全为1
  61   1              if(P1!=0xfe)//判断第四列按键是否按下
  62   1              {
  63   2                      delay_10us(1000);//消抖
  64   2                      switch(P1)//保存第四列按键按下后的键值  
  65   2                      {
  66   3                              case 0x7e: key_value=4;break;
  67   3                              case 0xbe: key_value=8;break;
  68   3                              case 0xde: key_value=12;break;
  69   3                              case 0xee: key_value=16;break;
  70   3                      }
  71   2              }
  72   1              while(P1!=0xfe);//等待按键松开
  73   1          
  74   1          return key_value;
  75   1      }
  76          
  77          // 线翻转法
  78          uint flip_scan(){
  79   1          uint key_value = 0;
  80   1          
  81   1          P1=0x0f;//给所有行赋值0，列全为1
  82   1              if(P1!=0x0f)//判断按键是否按下
  83   1              {
  84   2                      delay_10us(1000);//消抖
  85   2                      if(P1!=0x0f)
  86   2                      {
  87   3                              //测试列
  88   3                              switch(P1)//保存行为0，按键按下后的列值 
  89   3                              {
  90   4                                      case 0x07: key_value=1;break;
  91   4                                      case 0x0b: key_value=2;break;
  92   4                                      case 0x0d: key_value=3;break;
  93   4                                      case 0x0e: key_value=4;break;
  94   4                              }
  95   3                              //测试行
  96   3                              P1=0xf0;
  97   3                              switch(P1)//保存列为0，按键按下后的键值 
  98   3                              {
  99   4                                      case 0x70: key_value=key_value;break;
 100   4                                      case 0xb0: key_value=key_value+4;break;
 101   4                                      case 0xd0: key_value=key_value+8;break;
 102   4                                      case 0xe0: key_value=key_value+12;break;
 103   4                              }
 104   3                              while(P1!=0xf0);//等待按键松开  
 105   3                      }
 106   2              }
 107   1              return key_value;       
 108   1      }
 109          
 110          void main(){
 111   1          uint key;
 112   1          while(1){
 113   2              key = flip_scan();
 114   2              if(key != 0){
 115   3                  P0 = table[key-1];
 116   3              }
C51 COMPILER V9.60.7.0   MAIN                                                              09/18/2024 17:15:41 PAGE 3   

 117   2          }
 118   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    379    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
